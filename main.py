# -*- coding: utf-8 -*-
"""Blockchain-Based Data Integrity System

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i-uvkYYViCU_McP0-NQNTIRexn3LJlLU
"""

!pip install cryptography

import hashlib
import json
import os
import time
from cryptography.fernet import Fernet

# ==========================================
# PART 1: THE VAULT (ENCRYPTION)
# Responsible for Confidentiality (Hiding Data)
# ==========================================
class SecureVault:
    def __init__(self):
        # Generate a high-security key (AES-128)
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
        print(f"üîë VAULT INITIALIZED. Key: {self.key.decode()[0:10]}... (Hidden)")

    def encrypt_file(self, file_path):
        """Reads a file, encrypts it, and saves it back."""
        if not os.path.exists(file_path):
            print(f"‚ùå Error: File {file_path} not found.")
            return

        with open(file_path, "rb") as f:
            original_data = f.read()

        encrypted_data = self.cipher.encrypt(original_data)

        with open(file_path, "wb") as f:
            f.write(encrypted_data)
        print(f"üîí ENCRYPTED: '{file_path}' is now unreadable.")

    def decrypt_file(self, file_path):
        """Reads an encrypted file, decrypts it, and restores original."""
        if not os.path.exists(file_path):
            return

        with open(file_path, "rb") as f:
            encrypted_data = f.read()

        try:
            decrypted_data = self.cipher.decrypt(encrypted_data)
            with open(file_path, "wb") as f:
                f.write(decrypted_data)
            print(f"üîì DECRYPTED: '{file_path}' restored to original.")
        except Exception:
            print(f"‚ùå DECRYPTION FAILED: Key mismatch or data corrupted.")

# ==========================================
# PART 2: THE BLOCKCHAIN (INTEGRITY)
# Responsible for Tamper Detection
# ==========================================
class Block:
    def __init__(self, index, file_path, file_hash, previous_hash):
        self.index = index
        self.timestamp = time.time()
        self.file_path = file_path
        self.file_hash = file_hash
        self.previous_hash = previous_hash
        self.nonce = 0
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        block_string = json.dumps({
            "index": self.index,
            "timestamp": self.timestamp,
            "file_path": self.file_path,
            "file_hash": self.file_hash,
            "previous_hash": self.previous_hash,
            "nonce": self.nonce
        }, sort_keys=True).encode()
        return hashlib.sha256(block_string).hexdigest()

class Blockchain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]

    def create_genesis_block(self):
        return Block(0, "Genesis Block", "0", "0")

    def get_latest_block(self):
        return self.chain[-1]

    def add_file(self, file_path):
        """Hashes the CURRENT state of the file and locks it in a block."""
        if not os.path.exists(file_path):
            return

        # Calculate SHA-256 of the file content
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            # Read in chunks to handle large files
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        file_hash = sha256_hash.hexdigest()

        new_block = Block(
            len(self.chain),
            file_path,
            file_hash,
            self.get_latest_block().hash
        )
        self.chain.append(new_block)
        print(f"üîó BLOCK #{new_block.index} ADDED. Hash: {new_block.hash[:15]}...")

    def validate_chain(self):
        print("\nüîé STARTING FORENSIC AUDIT...")
        is_valid = True
        for i in range(1, len(self.chain)):
            current = self.chain[i]
            previous = self.chain[i-1]

            # 1. Check Blockchain Continuity
            if current.previous_hash != previous.hash:
                print(f"‚ùå CRITICAL: Chain broken between Block #{previous.index} and #{current.index}!")
                is_valid = False

            # 2. Check File Integrity on Disk
            if os.path.exists(current.file_path):
                sha256_hash = hashlib.sha256()
                with open(current.file_path, "rb") as f:
                    for byte_block in iter(lambda: f.read(4096), b""):
                        sha256_hash.update(byte_block)

                if sha256_hash.hexdigest() != current.file_hash:
                    print(f"‚ö†Ô∏è TAMPER ALERT: File '{current.file_path}' modified after logging!")
                    is_valid = False

        if is_valid:
            print("‚úÖ SYSTEM SECURE: All files match their blockchain records.")
        return is_valid

# ==========================================
# PART 3: THE DEMONSTRATION
# Simulates a Real-World Scenario
# ==========================================
if __name__ == "__main__":
    # 1. Initialize Systems
    vault = SecureVault()
    gov_chain = Blockchain()
    filename = "top_secret_intel.txt"

    # 2. Create a Dummy Government File
    print("\n--- [STEP 1] CREATING FILE ---")
    with open(filename, "w") as f:
        f.write("CONFIDENTIAL: The nuclear launch code is 123456.")
    print(f"üìÑ Created '{filename}' with sensitive data.")

    # 3. Encrypt the File (Confidentiality)
    print("\n--- [STEP 2] ENCRYPTING DATA ---")
    vault.encrypt_file(filename)

    # 4. Add to Blockchain (Integrity)
    print("\n--- [STEP 3] LOGGING TO BLOCKCHAIN ---")
    gov_chain.add_file(filename)

    # 5. Verify Everything is Safe
    gov_chain.validate_chain()

    # 6. Simulate a Cyber Attack (Tampering)
    print("\n--- [STEP 4] ‚ò†Ô∏è SIMULATING HACKER ATTACK ---")
    time.sleep(1)
    # Hacker overwrites the encrypted file with their own data
    with open(filename, "wb") as f:
        f.write(b"HACKED_DATA_CORRUPTION_PAYLOAD")
    print(f"‚ö†Ô∏è Hacker modified '{filename}' on the disk!")

    # 7. Forensic Check (Should Fail)
    print("\n--- [STEP 5] POST-ATTACK AUDIT ---")
    if not gov_chain.validate_chain():
        print("üö® INTRUSION DETECTED! ISOLATING SYSTEM...")

    # 8. Try to Decrypt (Will fail because file is corrupted)
    print("\n--- [STEP 6] ATTEMPTING RESTORATION ---")
    vault.decrypt_file(filename)











